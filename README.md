Here is the `README.md` that you can directly copy and paste:

---

# Malware Image Classification using CNN

This project implements a Convolutional Neural Network (CNN) model to classify malware images into multiple classes using the [Blended Malware Image Dataset](https://www.kaggle.com/datasets/gauravpendharkar/blended-malware-image-dataset). The dataset contains images of various malware types, and this project focuses on training a multi-class classification model with TensorFlow and Keras.

## Table of Contents

- [Dataset](#dataset)
- [Installation](#installation)
- [Project Structure](#project-structure)
- [Model Architecture](#model-architecture)
- [Training the Model](#training-the-model)
- [Evaluating the Model](#evaluating-the-model)
- [Prediction on New Images](#prediction-on-new-images)
- [License](#license)

## Dataset

The dataset used is the **Blended Malware Image Dataset**, which can be downloaded from Kaggle. It contains grayscale images representing different types of malware, and is divided into a training and validation set.

- **Training images**: Located in `/content/malware_dataset/train`
- **Validation images**: Located in `/content/malware_dataset/val`

## Installation

### Prerequisites

1. Python 3.7+
2. TensorFlow 2.x
3. OpenCV
4. Kaggle API

### Steps

1. Clone the repository:

   ```bash
   git clone https://github.com/yourusername/malware-classification.git
   cd malware-classification
   ```

2. Install the required Python packages:

   ```bash
   pip install tensorflow opencv-python matplotlib
   ```

3. Set up the Kaggle API to download the dataset:

   - Place your `kaggle.json` file (which contains your Kaggle API credentials) in the home directory.
   - Run the following commands:

     ```bash
     mkdir -p ~/.kaggle
     cp kaggle.json ~/.kaggle/
     chmod 600 ~/.kaggle/kaggle.json
     kaggle datasets download -d gauravpendharkar/blended-malware-image-dataset
     ```

4. Extract the dataset:

   ```python
   import zipfile
   zip_ref = zipfile.ZipFile('/content/blended-malware-image-dataset.zip', 'r')
   zip_ref.extractall('/content')
   zip_ref.close()
   ```

## Project Structure

```
├── blended-malware-image-dataset.zip      # Dataset downloaded from Kaggle
├── malware_dataset/                       # Extracted dataset
├── README.md                              # Project description and instructions
├── model_training_script.py               # Script for model training and prediction
└── kaggle.json                            # Kaggle API token (not included in the repository)
```

## Model Architecture

The model used is a deep CNN for multi-class classification. Here’s a summary of the architecture:

- **Input Layer**: Takes in 256x256 RGB images.
- **Conv2D + BatchNormalization + LeakyReLU + MaxPooling2D**: Four blocks with increasing filter sizes (32, 64, 128, 256).
- **Flatten Layer**: Flattens the convolutional output to feed into fully connected layers.
- **Dense + Dropout**: Fully connected layers with dropout to prevent overfitting.
- **Output Layer**: Uses softmax activation for multi-class classification.

## Training the Model

The model is compiled with the following configuration:

- **Optimizer**: Adam with a learning rate of 0.001
- **Loss Function**: `sparse_categorical_crossentropy` for multi-class classification
- **Metrics**: Accuracy

Early stopping is used to avoid overfitting, and a learning rate scheduler gradually decreases the learning rate.

To train the model, run the following code:

```python
history = model.fit(
    train_ds,
    epochs=20,
    validation_data=validation_ds,
    callbacks=[early_stopping, lr_scheduler]
)
```

## Evaluating the Model

You can evaluate the model performance by plotting training and validation accuracy and loss:

```python
# Plot accuracy
plt.plot(history.history['accuracy'])
plt.plot(history.history['val_accuracy'])
plt.title('Model Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend(['Train', 'Validation'], loc='upper left')
plt.show()

# Plot loss
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('Model Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend(['Train', 'Validation'], loc='upper left')
plt.show()
```

## Prediction on New Images

You can use the following function to predict the class of a new image:

```python
import cv2
import numpy as np
import matplotlib.pyplot as plt

def predict_image(image_path):
    test_image = cv2.imread(image_path)

    if test_image is None:
        print("Error: Image not loaded, check if the file path is correct.")
        return

    test_image = cv2.resize(test_image, (256, 256))
    test_image_normalized = test_image / 255.0
    test_image_normalized = np.expand_dims(test_image_normalized, axis=0)

    prediction = model.predict(test_image_normalized)
    predicted_class = np.argmax(prediction[0])

    # Update the class labels according to your dataset
    disease_names = ['d1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'd10',
                     'd11', 'd12', 'd13', 'd14', 'd15', 'd16', 'd17', 'd18', 'd19', 'd20',
                     'd21', 'd22', 'd23', 'd24', 'd25', 'd26', 'd27', 'd28', 'd29', 'd30', 'd31']

    print(f"Predicted Disease: {disease_names[predicted_class]}")

    plt.imshow(cv2.cvtColor(test_image, cv2.COLOR_BGR2RGB))
    plt.title(f'Prediction: {disease_names[predicted_class]}')
    plt.show()
```

To test a new image:

```python
test_image_path = '/content/malware_dataset/train/Agent/sample_image.png'
predict_image(test_image_path)
```

## License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for more details.

---

Feel free to modify it according to your specific requirements!
